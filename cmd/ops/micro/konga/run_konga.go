package konga

import (
	"fmt"
	"github.com/gogf/gf/v2/os/gfile"
	"strings"

	"github.com/gogf/gf-cli/v2/library/mlog"
	"github.com/gogf/gf/v2/os/gproc"
	"github.com/jettjia/go-micro-frame-cli/util"

	"github.com/jettjia/go-micro-frame-cli/constant"
)

func RunKonga() {
	mlog.Print("init kong and konga ...")

	host := util.GetOutboundIP()

	// 1. 安装 postgresql 和 migrations
	fmt.Println(`docker run -d --name ` + constant.PostgresName + ` \
           -p 5432:5432 \
           -e "POSTGRES_USER=` + constant.PostgresDBUser + `" \
           -e "POSTGRES_DB=` + constant.PostgresDB + `" \
           -e "POSTGRES_PASSWORD=` + constant.PostgresPwd + `" \
           postgres:12`)
	_, err := gproc.ShellExec(`docker run -d --name ` + constant.PostgresName + ` \
           -p 5432:5432 \
           -e "POSTGRES_USER=` + constant.PostgresDBUser + `" \
           -e "POSTGRES_DB=` + constant.PostgresDB + `" \
           -e "POSTGRES_PASSWORD=` + constant.PostgresPwd + `" \
           postgres:12`)
	if err != nil {
		mlog.Fatal("run postgresql err", err)
		return
	}
	// 运行临时Kong容器迁移数据库
	fmt.Println(`docker run --rm \
		-e "KONG_DATABASE=postgres" \
		-e "KONG_PG_HOST=` + host + `" \
		-e "KONG_PG_PASSWORD=` + constant.PostgresPwd + `" \
		-e "POSTGRES_USER=` + constant.PostgresDBUser + `" \
		-e "KONG_CASSANDRA_CONTACT_POINTS=` + constant.PostgresName + `" \
		kong kong migrations bootstrap`)
	_, err = gproc.ShellExec(`docker run --rm \
		-e "KONG_DATABASE=postgres" \
		-e "KONG_PG_HOST=` + host + `" \
		-e "KONG_PG_PASSWORD=` + constant.PostgresPwd + `" \
		-e "POSTGRES_USER=` + constant.PostgresDBUser + `" \
		-e "KONG_CASSANDRA_CONTACT_POINTS=` + constant.PostgresName + `" \
		kong kong migrations bootstrap`)
	//if err != nil {
	//	mlog.Fatal("run kong err", err)
	//	return
	//}

	// 2. 安装kong
	if !util.IsExists("kong-"+constant.KongVersion+".amd64.rpm") {
		_, err = gproc.ShellExec(`curl -Lo kong-` + constant.KongVersion + `.amd64.rpm $( rpm --eval "https://download.konghq.com/gateway-2.x-centos-%{centos_ver}/Packages/k/kong-` + constant.KongVersion + `.el%{centos_ver}.amd64.rpm")`)
		if err != nil {
			mlog.Fatal("down kong-"+constant.KongVersion+".amd64.rpm err", err)
			return
		}
	}

	fmt.Println(`sudo yum install kong-` + constant.KongVersion + `.amd64.rpm -y`)
	_, err = gproc.ShellExec(`sudo yum install kong-` + constant.KongVersion + `.amd64.rpm -y`)
	if err != nil {
		mlog.Fatal("install kong err", err)
		return
	}

	// 3. kong配置
	_, _ = gproc.ShellExec(`systemctl stop firewalld`)

	// 替换里面的配置
	newStr := strings.Replace(kong, "10.4.7.71", host, -1)

	err = gfile.PutContents("/etc/kong/kong.conf", newStr)
	if err != nil {
		mlog.Fatal("write /etc/kong/kong.conf err: ", err)
	}

	// 4. 启动kong
	_, err = gproc.ShellExec(`kong migrations bootstrap up -c /etc/kong/kong.conf`)
	if err != nil {
		mlog.Fatal("kong migrations bootstrap err", err)
		return
	}
	_, err = gproc.ShellExec(`kong start -c /etc/kong/kong.conf`)
	if err != nil {
		mlog.Fatal("kong start err", err)
		return
	}

	// 5. 添加防火墙规则
	_, _ = gproc.ShellExec(`firewall-cmd --zone=public --add-port=8001/tcp --permanent`)
	_, _ = gproc.ShellExec(`firewall-cmd --zone=public --add-port=8000/tcp --permanent`)
	_, _ = gproc.ShellExec(`sudo firewall-cmd --reload`)

	// 6. 安装konga
	_, err = gproc.ShellExec(`docker run -d -p 1337:1337 --name ` + constant.KongaName + ` pantsel/konga`)
	if err != nil {
		mlog.Fatal("konga run err", err)
		return
	}
	// 7. 返回信息
	mlog.Print("done!")

	mlog.Print("You can visit", "http://ip:8001")
	mlog.Print("Konga backstage", "http://ip:1337")
}

var (
	kong = "# -----------------------\n# Kong configuration file\n# -----------------------\n#\n# The commented-out settings shown in this file represent the default values.\n#\n# This file is read when `kong start` or `kong prepare` are used. Kong\n# generates the Nginx configuration with the settings specified in this file.\n#\n# All environment variables prefixed with `KONG_` and capitalized will override\n# the settings specified in this file.\n# Example:\n#   `log_level` setting -> `KONG_LOG_LEVEL` env variable\n#\n# Boolean values can be specified as `on`/`off` or `true`/`false`.\n# Lists must be specified as comma-separated strings.\n#\n# All comments in this file can be removed safely, including the\n# commented-out properties.\n# You can verify the integrity of your settings with `kong check <conf>`.\n\n#------------------------------------------------------------------------------\n# GENERAL\n#------------------------------------------------------------------------------\n\n#prefix = /usr/local/kong/       # Working directory. Equivalent to Nginx's\n                                 # prefix path, containing temporary files\n                                 # and logs.\n                                 # Each Kong process must have a separate\n                                 # working directory.\n\n#log_level = notice              # Log level of the Nginx server. Logs are\n                                 # found at `<prefix>/logs/error.log`.\n\n# See http://nginx.org/en/docs/ngx_core_module.html#error_log for a list\n# of accepted values.\n\n#proxy_access_log = logs/access.log       # Path for proxy port request access\n                                          # logs. Set this value to `off` to\n                                          # disable logging proxy requests.\n                                          # If this value is a relative path,\n                                          # it will be placed under the\n                                          # `prefix` location.\n\n\n#proxy_error_log = logs/error.log         # Path for proxy port request error\n                                          # logs. The granularity of these logs\n                                          # is adjusted by the `log_level`\n                                          # property.\n\n#proxy_stream_access_log = logs/access.log basic # Path for tcp streams proxy port access\n                                                 # logs. Set this value to `off` to\n                                                 # disable logging proxy requests.\n                                                 # If this value is a relative path,\n                                                 # it will be placed under the\n                                                 # `prefix` location.\n                                                 # `basic` is defined as `'$remote_addr [$time_local] '\n                                                 # '$protocol $status $bytes_sent $bytes_received '\n                                                 # '$session_time'`\n\n#proxy_stream_error_log = logs/error.log         # Path for tcp streams proxy port request error\n                                                 # logs. The granularity of these logs\n                                                 # is adjusted by the `log_level`\n                                                 # property.\n\n#admin_access_log = logs/admin_access.log # Path for Admin API request access\n                                          # logs. If Hybrid Mode is enabled\n                                          # and the current node is set to be\n                                          # the Control Plane, then the\n                                          # connection requests from Data Planes\n                                          # are also written to this file with\n                                          # server name \"kong_cluster_listener\".\n                                          #\n                                          # Set this value to `off` to\n                                          # disable logging Admin API requests.\n                                          # If this value is a relative path,\n                                          # it will be placed under the\n                                          # `prefix` location.\n\n#admin_error_log = logs/error.log         # Path for Admin API request error\n                                          # logs. The granularity of these logs\n                                          # is adjusted by the `log_level`\n                                          # property.\n\n#status_access_log = off                  # Path for Status API request access\n                                          # logs. The default value of `off`\n                                          # implies that logging for this API\n                                          # is disabled by default.\n                                          # If this value is a relative path,\n                                          # it will be placed under the\n                                          # `prefix` location.\n\n#status_error_log = logs/status_error.log # Path for Status API request error\n                                          # logs. The granularity of these logs\n                                          # is adjusted by the `log_level`\n                                          # property.\n\n#plugins = bundled               # Comma-separated list of plugins this node\n                                 # should load. By default, only plugins\n                                 # bundled in official distributions are\n                                 # loaded via the `bundled` keyword.\n                                 #\n                                 # Loading a plugin does not enable it by\n                                 # default, but only instructs Kong to load its\n                                 # source code, and allows to configure the\n                                 # plugin via the various related Admin API\n                                 # endpoints.\n                                 #\n                                 # The specified name(s) will be substituted as\n                                 # such in the Lua namespace:\n                                 # `kong.plugins.{name}.*`.\n                                 #\n                                 # When the `off` keyword is specified as the\n                                 # only value, no plugins will be loaded.\n                                 #\n                                 # `bundled` and plugin names can be mixed\n                                 # together, as the following examples suggest:\n                                 #\n                                 # - `plugins = bundled,custom-auth,custom-log`\n                                 #   will include the bundled plugins plus two\n                                 #   custom ones\n                                 # - `plugins = custom-auth,custom-log` will\n                                 #   *only* include the `custom-auth` and\n                                 #   `custom-log` plugins.\n                                 # - `plugins = off` will not include any\n                                 #   plugins\n                                 #\n                                 # **Note:** Kong will not start if some\n                                 # plugins were previously configured (i.e.\n                                 # have rows in the database) and are not\n                                 # specified in this list.  Before disabling a\n                                 # plugin, ensure all instances of it are\n                                 # removed before restarting Kong.\n                                 #\n                                 # **Note:** Limiting the amount of available\n                                 # plugins can improve P99 latency when\n                                 # experiencing LRU churning in the database\n                                 # cache (i.e. when the configured\n                                 # `mem_cache_size`) is full.\n\n#pluginserver_names =            # Comma-separated list of names for pluginserver\n                                 # processes.  The actual names are used for\n                                 # log messages and to relate the actual settings.\n\n#pluginserver_XXX_socket = <prefix>/<XXX>.socket            # Path to the unix socket\n                                                            # used by the <XXX> pluginserver.\n#pluginserver_XXX_start_cmd = /usr/local/bin/<XXX>          # Full command (including\n                                                            # any needed arguments) to\n                                                            # start the <XXX> pluginserver\n#pluginserver_XXX_query_cmd = /usr/local/bin/query_<XXX>    # Full command to \"query\" the\n                                                            # <XXX> pluginserver.  Should\n                                                            # produce a JSON with the\n                                                            # dump info of all plugins it\n                                                            # manages\n\n#port_maps =                     # With this configuration parameter, you can\n                                 # let the Kong to know about the port from\n                                 # which the packets are forwarded to it. This\n                                 # is fairly common when running Kong in a\n                                 # containerized or virtualized environment.\n                                 # For example, `port_maps=80:8000, 443:8443`\n                                 # instructs Kong that the port 80 is mapped\n                                 # to 8000 (and the port 443 to 8443), where\n                                 # 8000 and 8443 are the ports that Kong is\n                                 # listening to.\n                                 #\n                                 # This parameter helps Kong set a proper\n                                 # forwarded upstream HTTP request header or to\n                                 # get the proper forwarded port with the Kong PDK\n                                 # (in case other means determining it has\n                                 # failed). It changes routing by a destination\n                                 # port to route by a port from which packets\n                                 # are forwarded to Kong, and similarly it\n                                 # changes the default plugin log serializer to\n                                 # use the port according to this mapping\n                                 # instead of reporting the port Kong is\n                                 # listening to.\n\n#anonymous_reports = on          # Send anonymous usage data such as error\n                                 # stack traces to help improve Kong.\n\n#------------------------------------------------------------------------------\n# HYBRID MODE\n#------------------------------------------------------------------------------\n\n#role = traditional              # Use this setting to enable Hybrid Mode,\n                                 # This allows running some Kong nodes in a\n                                 # control plane role with a database and\n                                 # have them deliver configuration updates\n                                 # to other nodes running to DB-less running in\n                                 # a Data Plane role.\n                                 #\n                                 # Valid values to this setting are:\n                                 #\n                                 # - `traditional`: do not use Hybrid Mode.\n                                 # - `control_plane`: this node runs in a\n                                 #   control plane role. It can use a database\n                                 #   and will deliver configuration updates\n                                 #   to data plane nodes.\n                                 # - `data_plane`: this is a data plane node.\n                                 #   It runs DB-less and receives configuration\n                                 #   updates from a control plane node.\n\n#cluster_mtls = shared           # Sets the verification between nodes of the\n                                 # cluster.\n                                 #\n                                 # Valid values to this setting are:\n                                 #\n                                 # - `shared`: use a shared certificate/key\n                                 #   pair specified with the `cluster_cert`\n                                 #   and `cluster_cert_key` settings.\n                                 #   Note that CP and DP nodes have to present\n                                 #   the same certificate to establish mTLS\n                                 #   connections.\n                                 # - `pki`: use `cluster_ca_cert`,\n                                 #   `cluster_server_name` and `cluster_cert`\n                                 #   for verification.\n                                 #   These are different certificates for each\n                                 #   DP node, but issued by a cluster-wide\n                                 #   common CA certificate: `cluster_ca_cert`.\n\n#cluster_cert =                  # Filename of the cluster certificate to use\n                                 # when establishing secure communication\n                                 # between control and data plane nodes.\n                                 # You can use the `kong hybrid` command to\n                                 # generate the certificate/key pair.\n                                 # Under `shared` mode, it must be the same\n                                 # for all nodes.  Under `pki` mode it\n                                 # should be a different certificate for each\n                                 # DP node.\n\n#cluster_cert_key =              # Filename of the cluster certificate key to\n                                 # use when establishing secure communication\n                                 # between control and data plane nodes.\n                                 # You can use the `kong hybrid` command to\n                                 # generate the certificate/key pair.\n                                 # Under `shared` mode, it must be the same\n                                 # for all nodes.  Under `pki` mode it\n                                 # should be a different certificate for each\n                                 # DP node.\n\n#cluster_ca_cert =               # The trusted CA certificate file in PEM\n                                 # format used for Control Plane to verify\n                                 # Data Plane's certificate and Data Plane\n                                 # to verify Control Plane's certificate.\n                                 # Required on data plane if `cluster_mtls`\n                                 # is set to `pki`.\n                                 # If Control Plane certificate is issued\n                                 # by a well known CA, user can set\n                                 # `lua_ssl_trusted_certificate=system`\n                                 # on Data Plane and leave this field empty.\n                                 #\n                                 # This field is ignored if `cluster_mtls` is\n                                 # set to `shared`.\n\n#------------------------------------------------------------------------------\n# HYBRID MODE DATA PLANE\n#------------------------------------------------------------------------------\n\n#cluster_server_name =           # The server name used in the SNI of the TLS\n                                 # connection from a DP node to a CP node.\n                                 # Must match the Common Name (CN) or Subject\n                                 # Alternative Name (SAN) found in the CP\n                                 # certificate.\n                                 # If `cluster_mtls` is set to\n                                 # `shared`, this setting is ignored and\n                                 # `kong_clustering` is used.\n\n#cluster_control_plane =         # To be used by data plane nodes only:\n                                 # address of the control plane node from\n                                 # which configuration updates will be fetched,\n                                 # in `host:port` format.\n\n#------------------------------------------------------------------------------\n# HYBRID MODE CONTROL PLANE\n#------------------------------------------------------------------------------\n\n#cluster_listen = 0.0.0.0:8005\n                         # Comma-separated list of addresses and ports on\n                         # which the cluster control plane server should listen\n                         # for data plane connections.\n                         # The cluster communication port of the control plane\n                         # must be accessible by all the data planes\n                         # within the same cluster. This port is mTLS protected\n                         # to ensure end-to-end security and integrity.\n                         #\n                         # This setting has no effect if `role` is not set to\n                         # `control_plane`.\n                         #\n                         # Connection made to this endpoint are logged\n                         # to the same location as Admin API access logs.\n                         # See `admin_access_log` config description for more\n                         # information.\n\n#cluster_data_plane_purge_delay = 1209600\n                         # How many seconds must pass from the time a DP node\n                         # becomes offline to the time its entry gets removed\n                         # from the database, as returned by the\n                         # /clustering/data-planes Admin API endpoint.\n                         #\n                         # This is to prevent the cluster data plane table from\n                         # growing indefinitely. The default is set to\n                         # 14 days. That is, if CP haven't heard from a DP for\n                         # 14 days, its entry will be removed.\n\n#cluster_ocsp = off\n                         # Whether to check for revocation status of DP\n                         # certificates using OCSP (Online Certificate Status Protocol).\n                         # If enabled, the DP certificate should contain the\n                         # \"Certificate Authority Information Access\" extension\n                         # and the OCSP method with URI of which the OCSP responder\n                         # can be reached from CP.\n                         #\n                         # OCSP checks are only performed on CP nodes, it has no\n                         # effect on DP nodes.\n                         #\n                         # Valid values to this setting are:\n                         #\n                         # - `on`: OCSP revocation check is enabled and DP\n                         #   must pass the check in order to establish\n                         #   connection with CP.\n                         # - `off`: OCSP revocation check is disabled.\n                         # - `optional`: OCSP revocation check will be attempted,\n                         #   however, if the required extension is not\n                         #   found inside DP provided certificate\n                         #   or communication with the OCSP responder\n                         #   failed, then DP is still allowed through.\n#------------------------------------------------------------------------------\n# NGINX\n#------------------------------------------------------------------------------\n\nproxy_listen = 0.0.0.0:8000 reuseport backlog=16384, 0.0.0.0:8443 http2 ssl reuseport backlog=16384\n                         # Comma-separated list of addresses and ports on\n                         # which the proxy server should listen for\n                         # HTTP/HTTPS traffic.\n                         # The proxy server is the public entry point of Kong,\n                         # which proxies traffic from your consumers to your\n                         # backend services. This value accepts IPv4, IPv6, and\n                         # hostnames.\n                         #\n                         # Some suffixes can be specified for each pair:\n                         #\n                         # - `ssl` will require that all connections made\n                         #   through a particular address/port be made with TLS\n                         #   enabled.\n                         # - `http2` will allow for clients to open HTTP/2\n                         #   connections to Kong's proxy server.\n                         # - `proxy_protocol` will enable usage of the\n                         #   PROXY protocol for a given address/port.\n                         # - `deferred` instructs to use a deferred accept on\n                         #   Linux (the TCP_DEFER_ACCEPT socket option).\n                         # - `bind` instructs to make a separate bind() call\n                         #   for a given address:port pair.\n                         # - `reuseport` instructs to create an individual\n                         #   listening socket for each worker process\n                         #   allowing the Kernel to better distribute incoming\n                         #   connections between worker processes\n                         # - `backlog=N` sets the maximum length for the queue\n                         #   of pending TCP connections. This number should\n                         #   not be too small in order to prevent clients\n                         #   seeing \"Connection refused\" error connecting to\n                         #   a busy Kong instance.\n                         #   **Note:** on Linux, this value is limited by the\n                         #   setting of `net.core.somaxconn` Kernel parameter.\n                         #   In order for the larger `backlog` set here to take\n                         #   effect it is necessary to raise\n                         #   `net.core.somaxconn` at the same time to match or\n                         #   exceed the `backlog` number set.\n                         #\n                         # This value can be set to `off`, thus disabling\n                         # the HTTP/HTTPS proxy port for this node.\n                         # If stream_listen is also set to `off`, this enables\n                         # 'control-plane' mode for this node\n                         # (in which all traffic proxying capabilities are\n                         # disabled). This node can then be used only to\n                         # configure a cluster of Kong\n                         # nodes connected to the same datastore.\n                         #\n                         # Example:\n                         # `proxy_listen = 0.0.0.0:443 ssl, 0.0.0.0:444 http2 ssl`\n                         #\n                         # See http://nginx.org/en/docs/http/ngx_http_core_module.html#listen\n                         # for a description of the accepted formats for this\n                         # and other `*_listen` values.\n                         #\n                         # See https://www.nginx.com/resources/admin-guide/proxy-protocol/\n                         # for more details about the `proxy_protocol`\n                         # parameter.\n                         #\n                         # Not all `*_listen` values accept all formats\n                         # specified in nginx's documentation.\n\n#stream_listen = off\n                         # Comma-separated list of addresses and ports on\n                         # which the stream mode should listen.\n                         #\n                         # This value accepts IPv4, IPv6, and hostnames.\n                         # Some suffixes can be specified for each pair:\n                         # - `ssl` will require that all connections made\n                         #   through a particular address/port be made with TLS\n                         #   enabled.\n                         # - `proxy_protocol` will enable usage of the\n                         #   PROXY protocol for a given address/port.\n                         # - `bind` instructs to make a separate bind() call\n                         #   for a given address:port pair.\n                         # - `reuseport` instructs to create an individual\n                         #   listening socket for each worker process\n                         #   allowing the Kernel to better distribute incoming\n                         #   connections between worker processes\n                         # - `backlog=N` sets the maximum length for the queue\n                         #   of pending TCP connections. This number should\n                         #   not be too small in order to prevent clients\n                         #   seeing \"Connection refused\" error connecting to\n                         #   a busy Kong instance.\n                         #   **Note:** on Linux, this value is limited by the\n                         #   setting of `net.core.somaxconn` Kernel parameter.\n                         #   In order for the larger `backlog` set here to take\n                         #   effect it is necessary to raise\n                         #   `net.core.somaxconn` at the same time to match or\n                         #   exceed the `backlog` number set.\n                         #\n                         # Examples:\n                         #\n                         # ```\n                         # stream_listen = 127.0.0.1:7000 reuseport backlog=16384\n                         # stream_listen = 0.0.0.0:989 reuseport backlog=65536, 0.0.0.0:20\n                         # stream_listen = [::1]:1234 backlog=16384\n                         # ```\n                         #\n                         # By default this value is set to `off`, thus\n                         # disabling the stream proxy port for this node.\n\n# See http://nginx.org/en/docs/stream/ngx_stream_core_module.html#listen\n# for a description of the formats that Kong might accept in stream_listen.\n\nadmin_listen = 0.0.0.0:8001 reuseport backlog=16384, 0.0.0.0:8444 http2 ssl reuseport backlog=16384\n                         # Comma-separated list of addresses and ports on\n                         # which the Admin interface should listen.\n                         # The Admin interface is the API allowing you to\n                         # configure and manage Kong.\n                         # Access to this interface should be *restricted*\n                         # to Kong administrators *only*. This value accepts\n                         # IPv4, IPv6, and hostnames.\n                         #\n                         # Some suffixes can be specified for each pair:\n                         #\n                         # - `ssl` will require that all connections made\n                         #   through a particular address/port be made with TLS\n                         #   enabled.\n                         # - `http2` will allow for clients to open HTTP/2\n                         #   connections to Kong's proxy server.\n                         # - `proxy_protocol` will enable usage of the\n                         #   PROXY protocol for a given address/port.\n                         # - `deferred` instructs to use a deferred accept on\n                         #   Linux (the TCP_DEFER_ACCEPT socket option).\n                         # - `bind` instructs to make a separate bind() call\n                         #   for a given address:port pair.\n                         # - `reuseport` instructs to create an individual\n                         #   listening socket for each worker process\n                         #   allowing the Kernel to better distribute incoming\n                         #   connections between worker processes\n                         # - `backlog=N` sets the maximum length for the queue\n                         #   of pending TCP connections. This number should\n                         #   not be too small in order to prevent clients\n                         #   seeing \"Connection refused\" error connecting to\n                         #   a busy Kong instance.\n                         #   **Note:** on Linux, this value is limited by the\n                         #   setting of `net.core.somaxconn` Kernel parameter.\n                         #   In order for the larger `backlog` set here to take\n                         #   effect it is necessary to raise\n                         #   `net.core.somaxconn` at the same time to match or\n                         #   exceed the `backlog` number set.\n                         #\n                         # This value can be set to `off`, thus disabling\n                         # the Admin interface for this node, enabling a\n                         # 'data-plane' mode (without configuration\n                         # capabilities) pulling its configuration changes\n                         # from the database.\n                         #\n                         # Example: `admin_listen = 127.0.0.1:8444 http2 ssl`\n\n#status_listen = off     # Comma-separated list of addresses and ports on\n                         # which the Status API should listen.\n                         # The Status API is a read-only endpoint\n                         # allowing monitoring tools to retrieve metrics,\n                         # healthiness, and other non-sensitive information\n                         # of the current Kong node.\n                         #\n                         # The following suffix can be specified for each pair:\n                         #\n                         # - `ssl` will require that all connections made\n                         #   through a particular address/port be made with TLS\n                         #   enabled.\n                         #\n                         # This value can be set to `off`, disabling\n                         # the Status API for this node.\n                         #\n                         # Example: `status_listen = 0.0.0.0:8100`\n\n\n#nginx_user = kong kong          # Defines user and group credentials used by\n                                 # worker processes. If group is omitted, a\n                                 # group whose name equals that of user is\n                                 # used.\n                                 #\n                                 # Example: `nginx_user = nginx www`\n                                 #\n                                 # **Note**: If the `kong` user and the `kong`\n                                 # group are not available, the default user\n                                 # and group credentials will be\n                                 # `nobody nobody`.\n\n#nginx_worker_processes = auto   # Determines the number of worker processes\n                                 # spawned by Nginx.\n                                 #\n                                 # See http://nginx.org/en/docs/ngx_core_module.html#worker_processes\n                                 # for detailed usage of the equivalent Nginx\n                                 # directive and a description of accepted\n                                 # values.\n\n#nginx_daemon = on               # Determines whether Nginx will run as a daemon\n                                 # or as a foreground process. Mainly useful\n                                 # for development or when running Kong inside\n                                 # a Docker environment.\n                                 #\n                                 # See http://nginx.org/en/docs/ngx_core_module.html#daemon.\n\n#mem_cache_size = 128m           # Size of each of the two in-memory caches\n                                 # for database entities. The accepted units are\n                                 # `k` and `m`, with a minimum recommended value of\n                                 # a few MBs.\n                                 #\n                                 # **Note**: As this option controls the size of two\n                                 # different cache entries, the total memory Kong\n                                 # uses to cache entities might be double this value.\n\n#ssl_cipher_suite = intermediate # Defines the TLS ciphers served by Nginx.\n                                 # Accepted values are `modern`,\n                                 # `intermediate`, `old`, or `custom`.\n                                 #\n                                 # See https://wiki.mozilla.org/Security/Server_Side_TLS\n                                 # for detailed descriptions of each cipher\n                                 # suite.\n\n#ssl_ciphers =                   # Defines a custom list of TLS ciphers to be\n                                 # served by Nginx. This list must conform to\n                                 # the pattern defined by `openssl ciphers`.\n                                 # This value is ignored if `ssl_cipher_suite`\n                                 # is not `custom`.\n\n#ssl_protocols = TLSv1.1 TLSv1.2 TLSv1.3\n                                 # Enables the specified protocols for\n                                 # client-side connections. The set of\n                                 # supported protocol versions also depends\n                                 # on the version of OpenSSL Kong was built\n                                 # with. This value is ignored if\n                                 # `ssl_cipher_suite` is not `custom`.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_protocols\n\n#ssl_prefer_server_ciphers = on  # Specifies that server ciphers should be\n                                 # preferred over client ciphers when using\n                                 # the SSLv3 and TLS protocols. This value is\n                                 # ignored if `ssl_cipher_suite` is not `custom`.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_prefer_server_ciphers\n\n#ssl_dhparam =                   # Defines DH parameters for DHE ciphers from the\n                                 # predefined groups: `ffdhe2048`, `ffdhe3072`,\n                                 # `ffdhe4096`, `ffdhe6144`, `ffdhe8192`, or\n                                 # from the absolute path to a parameters file.\n                                 #\n                                 # This value is ignored if `ssl_cipher_suite`\n                                 # is `modern` or `intermediate`. The reason is\n                                 # that `modern` has no ciphers that needs this,\n                                 # and `intermediate` uses `ffdhe2048`.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_dhparam\n\n#ssl_session_tickets = on        # Enables or disables session resumption through\n                                 # TLS session tickets. This has no impact when\n                                 # used with TLSv1.3.\n                                 #\n                                 # Kong enables this by default for performance\n                                 # reasons, but it has security implications:\n                                 # https://github.com/mozilla/server-side-tls/issues/135\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_tickets\n\n#ssl_session_timeout = 1d        # Specifies a time during which a client may\n                                 # reuse the session parameters. See the rationale:\n                                 # https://github.com/mozilla/server-side-tls/issues/198\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_session_timeout\n\n#ssl_cert =                      # Comma-separated list of the absolute path to the certificates for\n                                 # `proxy_listen` values with TLS enabled.\n                                 #\n                                 # If more than one certificates are specified, it can be used to provide\n                                 # alternate type of certificate (for example, ECC certificate) that will be served\n                                 # to clients that supports them. Note to properly serve using ECC certificates,\n                                 # it is recommended to also set `ssl_cipher_suite` to\n                                 # `modern` or `intermediate`.\n                                 #\n                                 # Unless this option is explicitly set, Kong will auto-generate\n                                 # a pair of default certificates (RSA + ECC) first time it starts up and use\n                                 # it for serving TLS requests.\n\n#ssl_cert_key =                  # Comma-separated list of the absolute path to the keys for\n                                 # `proxy_listen` values with TLS enabled.\n                                 #\n                                 # If more than one certificate was specified for `ssl_cert`, then this\n                                 # option should contain the corresponding key for all certificates\n                                 # provided in the same order.\n                                 #\n                                 # Unless this option is explicitly set, Kong will auto-generate\n                                 # a pair of default private keys (RSA + ECC) first time it starts up and use\n                                 # it for serving TLS requests.\n\n#client_ssl = off                # Determines if Nginx should attempt to send client-side\n                                 # TLS certificates and perform Mutual TLS Authentication\n                                 # with upstream service when proxying requests.\n\n#client_ssl_cert =               # If `client_ssl` is enabled, the absolute\n                                 # path to the client certificate for the `proxy_ssl_certificate` directive.\n                                 #\n                                 # This value can be overwritten dynamically with the `client_certificate`\n                                 # attribute of the `Service` object.\n\n#client_ssl_cert_key =           # If `client_ssl` is enabled, the absolute\n                                 # path to the client TLS key for the `proxy_ssl_certificate_key` directive.\n                                 #\n                                 # This value can be overwritten dynamically with the `client_certificate`\n                                 # attribute of the `Service` object.\n\n#admin_ssl_cert =                # Comma-separated list of the absolute path to the certificates for\n                                 # `admin_listen` values with TLS enabled.\n                                 #\n                                 # See docs for `ssl_cert` for detailed usage.\n\n#admin_ssl_cert_key =            # Comma-separated list of the absolute path to the keys for\n                                 # `admin_listen` values with TLS enabled.\n                                 #\n                                 # See docs for `ssl_cert_key` for detailed usage.\n\n#status_ssl_cert =               # Comma-separated list of the absolute path to the certificates for\n                                 # `status_listen` values with TLS enabled.\n                                 #\n                                 # See docs for `ssl_cert` for detailed usage.\n\n#status_ssl_cert_key =           # Comma-separated list of the absolute path to the keys for\n                                 # `status_listen` values with TLS enabled.\n                                 #\n                                 # See docs for `ssl_cert_key` for detailed usage.\n\n#headers = server_tokens, latency_tokens\n                                 # Comma-separated list of headers Kong should\n                                 # inject in client responses.\n                                 #\n                                 # Accepted values are:\n                                 # - `Server`: Injects `Server: kong/x.y.z`\n                                 #   on Kong-produced response (e.g. Admin\n                                 #   API, rejected requests from auth plugin).\n                                 # - `Via`: Injects `Via: kong/x.y.z` for\n                                 #   successfully proxied requests.\n                                 # - `X-Kong-Proxy-Latency`: Time taken\n                                 #   (in milliseconds) by Kong to process\n                                 #   a request and run all plugins before\n                                 #   proxying the request upstream.\n                                 # - `X-Kong-Response-Latency`: time taken\n                                 #   (in millisecond) by Kong to produce\n                                 #   a response in case of e.g. plugin\n                                 #   short-circuiting the request, or in\n                                 #   in case of an error.\n                                 # - `X-Kong-Upstream-Latency`: Time taken\n                                 #   (in milliseconds) by the upstream\n                                 #   service to send response headers.\n                                 # - `X-Kong-Admin-Latency`: Time taken\n                                 #   (in milliseconds) by Kong to process\n                                 #   an Admin API request.\n                                 # - `X-Kong-Upstream-Status`: The HTTP status\n                                 #   code returned by the upstream service.\n                                 #   This is particularly useful for clients to\n                                 #   distinguish upstream statuses if the\n                                 #   response is rewritten by a plugin.\n                                 # - `server_tokens`: Same as specifying both\n                                 #   `Server` and `Via`.\n                                 # - `latency_tokens`: Same as specifying\n                                 #   `X-Kong-Proxy-Latency`,\n                                 #   `X-Kong-Response-Latency`,\n                                 #   `X-Kong-Admin-Latency` and\n                                 #   `X-Kong-Upstream-Latency`\n                                 #\n                                 # In addition to those, this value can be set\n                                 # to `off`, which prevents Kong from injecting\n                                 # any of the above headers. Note that this\n                                 # does not prevent plugins from injecting\n                                 # headers of their own.\n                                 #\n                                 # Example: `headers = via, latency_tokens`\n\n#trusted_ips =                   # Defines trusted IP addresses blocks that are\n                                 # known to send correct `X-Forwarded-*`\n                                 # headers.\n                                 # Requests from trusted IPs make Kong forward\n                                 # their `X-Forwarded-*` headers upstream.\n                                 # Non-trusted requests make Kong insert its\n                                 # own `X-Forwarded-*` headers.\n                                 #\n                                 # This property also sets the\n                                 # `set_real_ip_from` directive(s) in the Nginx\n                                 # configuration. It accepts the same type of\n                                 # values (CIDR blocks) but as a\n                                 # comma-separated list.\n                                 #\n                                 # To trust *all* /!\\ IPs, set this value to\n                                 # `0.0.0.0/0,::/0`.\n                                 #\n                                 # If the special value `unix:` is specified,\n                                 # all UNIX-domain sockets will be trusted.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_realip_module.html#set_real_ip_from\n                                 # for examples of accepted values.\n\n#real_ip_header = X-Real-IP      # Defines the request header field whose value\n                                 # will be used to replace the client address.\n                                 # This value sets the `ngx_http_realip_module`\n                                 # directive of the same name in the Nginx\n                                 # configuration.\n                                 #\n                                 # If this value receives `proxy_protocol`:\n                                 #\n                                 # - at least one of the `proxy_listen` entries\n                                 #   must have the `proxy_protocol` flag\n                                 #   enabled.\n                                 # - the `proxy_protocol` parameter will be\n                                 #   appended to the `listen` directive of the\n                                 #   Nginx template.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_realip_module.html#real_ip_header\n                                 # for a description of this directive.\n\n#real_ip_recursive = off         # This value sets the `ngx_http_realip_module`\n                                 # directive of the same name in the Nginx\n                                 # configuration.\n                                 #\n                                 # See http://nginx.org/en/docs/http/ngx_http_realip_module.html#real_ip_recursive\n                                 # for a description of this directive.\n\n#error_default_type = text/plain  # Default MIME type to use when the request\n                                  # `Accept` header is missing and Nginx\n                                  # is returning an error for the request.\n                                  # Accepted values are `text/plain`,\n                                  # `text/html`, `application/json`, and\n                                  # `application/xml`.\n\n#upstream_keepalive_pool_size = 60  # Sets the default size of the upstream\n                                    # keepalive connection pools.\n                                    # Upstream keepalive connection pools\n                                    # are segmented by the `dst ip/dst\n                                    # port/SNI` attributes of a connection.\n                                    # A value of `0` will disable upstream\n                                    # keepalive connections by default, forcing\n                                    # each upstream request to open a new\n                                    # connection.\n\n#upstream_keepalive_max_requests = 100  # Sets the default maximum number of\n                                        # requests than can be proxied upstream\n                                        # through one keepalive connection.\n                                        # After the maximum number of requests\n                                        # is reached, the connection will be\n                                        # closed.\n                                        # A value of `0` will disable this\n                                        # behavior, and a keepalive connection\n                                        # can be used to proxy an indefinite\n                                        # number of requests.\n\n#upstream_keepalive_idle_timeout = 60   # Sets the default timeout (in seconds)\n                                        # for which an upstream keepalive\n                                        # connection should be kept open. When\n                                        # the timeout is reached while the\n                                        # connection has not been reused, it\n                                        # will be closed.\n                                        # A value of `0` will disable this\n                                        # behavior, and an idle keepalive\n                                        # connection may be kept open\n                                        # indefinitely.\n\n#------------------------------------------------------------------------------\n# NGINX injected directives\n#------------------------------------------------------------------------------\n\n# Nginx directives can be dynamically injected in the runtime nginx.conf file\n# without requiring a custom Nginx configuration template.\n#\n# All configuration properties respecting the naming scheme\n# `nginx_<namespace>_<directive>` will result in `<directive>` being injected in\n# the Nginx configuration block corresponding to the property's `<namespace>`.\n# Example:\n#   `nginx_proxy_large_client_header_buffers = 8 24k`\n#\n#   Will inject the following directive in Kong's proxy `server {}` block:\n#\n#   `large_client_header_buffers 8 24k;`\n#\n# The following namespaces are supported:\n#\n# - `nginx_main_<directive>`: Injects `<directive>` in Kong's configuration\n#   `main` context.\n# - `nginx_events_<directive>`: Injects `<directive>` in Kong's `events {}`\n#    block.\n# - `nginx_http_<directive>`: Injects `<directive>` in Kong's `http {}` block.\n# - `nginx_proxy_<directive>`: Injects `<directive>` in Kong's proxy\n#   `server {}` block.\n# - `nginx_upstream_<directive>`: Injects `<directive>` in Kong's proxy\n#   `upstream {}` block.\n# - `nginx_admin_<directive>`: Injects `<directive>` in Kong's Admin API\n#   `server {}` block.\n# - `nginx_status_<directive>`: Injects `<directive>` in Kong's Status API\n#   `server {}` block  (only effective if `status_listen` is enabled).\n# - `nginx_stream_<directive>`: Injects `<directive>` in Kong's stream module\n#   `stream {}` block (only effective if `stream_listen` is enabled).\n# - `nginx_sproxy_<directive>`: Injects `<directive>` in Kong's stream module\n#   `server {}` block (only effective if `stream_listen` is enabled).\n# - `nginx_supstream_<directive>`: Injects `<directive>` in Kong's stream\n#   module `upstream {}` block.\n#\n# As with other configuration properties, Nginx directives can be injected via\n# environment variables when capitalized and prefixed with `KONG_`.\n# Example:\n#   `KONG_NGINX_HTTP_SSL_PROTOCOLS` -> `nginx_http_ssl_protocols`\n#\n#   Will inject the following directive in Kong's `http {}` block:\n#\n#   `ssl_protocols <value>;`\n#\n#   If different sets of protocols are desired between the proxy and Admin API\n#   server, you may specify `nginx_proxy_ssl_protocols` and/or\n#   `nginx_admin_ssl_protocols`, both of which taking precedence over the\n#   `http {}` block.\n\n#nginx_main_worker_rlimit_nofile = auto\n                                 # Changes the limit on the maximum number of open files\n                                 # for worker processes.\n                                 #\n                                 # The special and default value of `auto` sets this\n                                 # value to `ulimit -n` with the upper bound limited to\n                                 # 16384 as a measure to protect against excess memory use.\n                                 #\n                                 # See http://nginx.org/en/docs/ngx_core_module.html#worker_rlimit_nofile\n\n#nginx_events_worker_connections = auto\n                                 # Sets the maximum number of simultaneous\n                                 # connections that can be opened by a worker process.\n                                 #\n                                 # The special and default value of `auto` sets this\n                                 # value to `ulimit -n` with the upper bound limited to\n                                 # 16384 as a measure to protect against excess memory use.\n                                 #\n                                 # See http://nginx.org/en/docs/ngx_core_module.html#worker_connections\n\n#nginx_http_client_header_buffer_size = 1k  # Sets buffer size for reading the\n                                            # client request headers.\n                                            # See http://nginx.org/en/docs/http/ngx_http_core_module.html#client_header_buffer_size\n\n#nginx_http_large_client_header_buffers = 4 8k  # Sets the maximum number and\n                                                # size of buffers used for\n                                                # reading large clients\n                                                # requests headers.\n                                                # See http://nginx.org/en/docs/http/ngx_http_core_module.html#large_client_header_buffers\n\n#nginx_http_client_max_body_size = 0  # Defines the maximum request body size\n                                      # allowed by requests proxied by Kong,\n                                      # specified in the Content-Length request\n                                      # header. If a request exceeds this\n                                      # limit, Kong will respond with a 413\n                                      # (Request Entity Too Large). Setting\n                                      # this value to 0 disables checking the\n                                      # request body size.\n                                      # See http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\n\n#nginx_admin_client_max_body_size = 10m  # Defines the maximum request body size for\n                                         # Admin API.\n\n#nginx_http_client_body_buffer_size = 8k  # Defines the buffer size for reading\n                                          # the request body. If the client\n                                          # request body is larger than this\n                                          # value, the body will be buffered to\n                                          # disk. Note that when the body is\n                                          # buffered to disk, Kong plugins that\n                                          # access or manipulate the request\n                                          # body may not work, so it is\n                                          # advisable to set this value as high\n                                          # as possible (e.g., set it as high\n                                          # as `client_max_body_size` to force\n                                          # request bodies to be kept in\n                                          # memory). Do note that\n                                          # high-concurrency environments will\n                                          # require significant memory\n                                          # allocations to process many\n                                          # concurrent large request bodies.\n                                          # See http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\n\n#nginx_admin_client_body_buffer_size = 10m  # Defines the buffer size for reading\n                                            # the request body on Admin API.\n\n#nginx_http_lua_regex_match_limit = 100000  # Global `MATCH_LIMIT` for PCRE\n                                            # regex matching. The default of `100000` should ensure\n                                            # at worst any regex Kong executes could finish within\n                                            # roughly 2 seconds.\n\n#------------------------------------------------------------------------------\n# DATASTORE\n#------------------------------------------------------------------------------\n\n# Kong can run with a database to store coordinated data between Kong nodes in\n# a cluster, or without a database, where each node stores its information\n# independently in memory.\n#\n# When using a database, Kong will store data for all its entities (such as\n# Routes, Services, Consumers, and Plugins) in either Cassandra or PostgreSQL,\n# and all Kong nodes belonging to the same cluster must connect themselves\n# to the same database.\n#\n# Kong supports the following database versions:\n# - **PostgreSQL**: 9.5 and above.\n# - **Cassandra**: 2.2 and above.\n#\n# When not using a database, Kong is said to be in \"DB-less mode\": it will keep\n# its entities in memory, and each node needs to have this data entered via a\n# declarative configuration file, which can be specified through the\n# `declarative_config` property, or via the Admin API using the `/config`\n# endpoint.\n#\n# When using Postgres as the backend storage, you can optionally enable Kong\n# to serve read queries from a separate database instance.\n# When the number of proxies is large, this can greatly reduce the load\n# on the main Postgres instance and achieve better scalability. It may also\n# reduce the latency jitter if the Kong proxy node's latency to the main\n# Postgres instance is high.\n#\n# The read-only Postgres instance only serves read queries and write\n# queries still goes to the main connection. The read-only Postgres instance\n# can be eventually consistent while replicating changes from the main\n# instance.\n#\n# At least the `pg_ro_host` config is needed to enable this feature.\n# By default, all other database config for the read-only connection are\n# inherited from the corresponding main connection config described above but\n# may be optionally overwritten explicitly using the `pg_ro_*` config below.\n\ndatabase = postgres             # Determines which of PostgreSQL or Cassandra\n                                 # this node will use as its datastore.\n                                 # Accepted values are `postgres`,\n                                 # `cassandra`, and `off`.\n\npg_host = 10.4.7.71             # Host of the Postgres server.\npg_port = 5432                  # Port of the Postgres server.\npg_timeout = 5000               # Defines the timeout (in ms), for connecting,\n                                 # reading and writing.\n\npg_user = kong                  # Postgres user.\npg_password = kong                  # Postgres user's password.\npg_database = kong              # The database name to connect to.\n\n#pg_schema =                     # The database schema to use. If unspecified,\n                                 # Kong will respect the `search_path` value of\n                                 # your PostgreSQL instance.\n\n#pg_ssl = off                    # Toggles client-server TLS connections\n                                 # between Kong and PostgreSQL.\n                                 # Because PostgreSQL uses the same port for TLS\n                                 # and non-TLS, this is only a hint. If the\n                                 # server does not support TLS, the established\n                                 # connection will be a plain one.\n\n#pg_ssl_verify = off             # Toggles server certificate verification if\n                                 # `pg_ssl` is enabled.\n                                 # See the `lua_ssl_trusted_certificate`\n                                 # setting to specify a certificate authority.\n\n#pg_max_concurrent_queries = 0   # Sets the maximum number of concurrent queries\n                                 # that can be executing at any given time. This\n                                 # limit is enforced per worker process; the\n                                 # total number of concurrent queries for this\n                                 # node will be will be:\n                                 # `pg_max_concurrent_queries * nginx_worker_processes`.\n                                 #\n                                 # The default value of 0 removes this\n                                 # concurrency limitation.\n\n#pg_semaphore_timeout = 60000    # Defines the timeout (in ms) after which\n                                 # PostgreSQL query semaphore resource\n                                 # acquisition attempts will fail. Such\n                                 # failures will generally result in the\n                                 # associated proxy or Admin API request\n                                 # failing with an HTTP 500 status code.\n                                 # Detailed discussion of this behavior is\n                                 # available in the online documentation.\n\n#pg_ro_host =                    # Same as `pg_host`, but for the\n                                 # read-only connection.\n                                 # **Note:** Refer to the documentation\n                                 # section above for detailed usage.\n\n#pg_ro_port = <pg_port>          # Same as `pg_port`, but for the\n                                 # read-only connection.\n\n#pg_ro_timeout = <pg_timeout>    # Same as `pg_timeout`, but for the\n                                 # read-only connection.\n\n#pg_ro_user = <pg_user>          # Same as `pg_user`, but for the\n                                 # read-only connection.\n\n#pg_ro_password = <pg_password>  # Same as `pg_password`, but for the\n                                 # read-only connection.\n\n#pg_ro_database = <pg_database>  # Same as `pg_database`, but for the\n                                 # read-only connection.\n\n#pg_ro_schema = <pg_schema>      # Same as `pg_schema`, but for the\n                                 # read-only connection.\n\n#pg_ro_ssl = <pg_ssl>            # Same as `pg_ssl`, but for the\n                                 # read-only connection.\n\n#pg_ro_ssl_verify = <pg_ssl_verify>\n                                 # Same as `pg_ssl_verify`, but for the\n                                 # read-only connection.\n\n#pg_ro_max_concurrent_queries = <pg_max_concurrent_queries>\n                                 # Same as `pg_max_concurrent_queries`, but for\n                                 # the read-only connection.\n                                 # Note: read-only concurrency is not shared\n                                 # with the main (read-write) connection.\n\n#pg_ro_semaphore_timeout = <pg_semaphore_timeout>\n                                 # Same as `pg_semaphore_timeout`, but for the\n                                 # read-only connection.\n\n#cassandra_contact_points = 127.0.0.1  # A comma-separated list of contact\n                                       # points to your cluster.\n                                       # You may specify IP addresses or\n                                       # hostnames. Note that the port\n                                       # component of SRV records will be\n                                       # ignored in favor of `cassandra_port`.\n                                       # When connecting to a multi-DC cluster,\n                                       # ensure that contact points from the\n                                       # local datacenter are specified first\n                                       # in this list.\n\n#cassandra_port = 9042           # The port on which your nodes are listening\n                                 # on. All your nodes and contact points must\n                                 # listen on the same port. Will be created if\n                                 # it doesn't exist.\n\n#cassandra_keyspace = kong       # The keyspace to use in your cluster.\n\n#cassandra_write_consistency = ONE  # Consistency setting to use when\n                                    # writing to the Cassandra cluster.\n\n#cassandra_read_consistency = ONE   # Consistency setting to use when\n                                    # reading from the Cassandra cluster.\n\n#cassandra_timeout = 5000        # Defines the timeout (in ms) for reading\n                                 # and writing.\n\n#cassandra_ssl = off             # Toggles client-to-node TLS connections\n                                 # between Kong and Cassandra.\n\n#cassandra_ssl_verify = off      # Toggles server certificate verification if\n                                 # `cassandra_ssl` is enabled.\n                                 # See the `lua_ssl_trusted_certificate`\n                                 # setting to specify a certificate authority.\n\n#cassandra_username = kong       # Username when using the\n                                 # `PasswordAuthenticator` scheme.\n\n#cassandra_password =            # Password when using the\n                                 # `PasswordAuthenticator` scheme.\n\n#cassandra_lb_policy = RequestRoundRobin  # Load balancing policy to use when\n                                          # distributing queries across your\n                                          # Cassandra cluster.\n                                          # Accepted values are:\n                                          # `RoundRobin`, `RequestRoundRobin`,\n                                          # `DCAwareRoundRobin`, and\n                                          # `RequestDCAwareRoundRobin`.\n                                          # Policies prefixed with \"Request\"\n                                          # make efficient use of established\n                                          # connections throughout the same\n                                          # request.\n                                          # Prefer \"DCAware\" policies if and\n                                          # only if you are using a\n                                          # multi-datacenter cluster.\n\n#cassandra_local_datacenter =    # When using the `DCAwareRoundRobin`\n                                 # or `RequestDCAwareRoundRobin` load\n                                 # balancing policy, you must specify the name\n                                 # of the local (closest) datacenter for this\n                                 # Kong node.\n\n#cassandra_refresh_frequency = 60          # Frequency (in seconds) at which\n                                           # the cluster topology will be\n                                           # checked for new or decommissioned\n                                           # nodes.\n                                           # A value of `0` will disable this\n                                           # check, and the cluster topology\n                                           # will never be refreshed.\n\n#cassandra_repl_strategy = SimpleStrategy  # When migrating for the first time,\n                                           # Kong will use this setting to\n                                           # create your keyspace.\n                                           # Accepted values are\n                                           # `SimpleStrategy` and\n                                           # `NetworkTopologyStrategy`.\n\n#cassandra_repl_factor = 1       # When migrating for the first time, Kong\n                                 # will create the keyspace with this\n                                 # replication factor when using the\n                                 # `SimpleStrategy`.\n\n#cassandra_data_centers = dc1:2,dc2:3  # When migrating for the first time,\n                                       # will use this setting when using the\n                                       # `NetworkTopologyStrategy`.\n                                       # The format is a comma-separated list\n                                       # made of `<dc_name>:<repl_factor>`.\n\n#cassandra_schema_consensus_timeout = 10000  # Defines the timeout (in ms) for\n                                             # the waiting period to reach a\n                                             # schema consensus between your\n                                             # Cassandra nodes.\n                                             # This value is only used during\n                                             # migrations.\n\n#declarative_config =           # The path to the declarative configuration\n                                # file which holds the specification of all\n                                # entities (Routes, Services, Consumers, etc.)\n                                # to be used when the `database` is set to\n                                # `off`.\n                                #\n                                # Entities are stored in Kong's in-memory cache,\n                                # so you must ensure that enough memory is\n                                # allocated to it via the `mem_cache_size`\n                                # property. You must also ensure that items\n                                # in the cache never expire, which means that\n                                # `db_cache_ttl` should preserve its default\n                                # value of 0.\n                                #\n                                # If the Hybrid mode `role` is set to `data_plane`\n                                # and there's no configuration cache file,\n                                # this configuration is used before connecting\n                                # to the Control Plane node as a user-controlled\n                                # fallback.\n\n#declarative_config_string =    # The declarative configuration as a string\n\n#------------------------------------------------------------------------------\n# DATASTORE CACHE\n#------------------------------------------------------------------------------\n\n# In order to avoid unnecessary communication with the datastore, Kong caches\n# entities (such as APIs, Consumers, Credentials...) for a configurable period\n# of time. It also handles invalidations if such an entity is updated.\n#\n# This section allows for configuring the behavior of Kong regarding the\n# caching of such configuration entities.\n\n#db_update_frequency = 5         # Frequency (in seconds) at which to check for\n                                 # updated entities with the datastore.\n                                 #\n                                 # When a node creates, updates, or deletes an\n                                 # entity via the Admin API, other nodes need\n                                 # to wait for the next poll (configured by\n                                 # this value) to eventually purge the old\n                                 # cached entity and start using the new one.\n\n#db_update_propagation = 0       # Time (in seconds) taken for an entity in the\n                                 # datastore to be propagated to replica nodes\n                                 # of another datacenter.\n                                 #\n                                 # When in a distributed environment such as\n                                 # a multi-datacenter Cassandra cluster, this\n                                 # value should be the maximum number of\n                                 # seconds taken by Cassandra to propagate a\n                                 # row to other datacenters.\n                                 #\n                                 # When set, this property will increase the\n                                 # time taken by Kong to propagate the change\n                                 # of an entity.\n                                 #\n                                 # Single-datacenter setups or PostgreSQL\n                                 # servers should suffer no such delays, and\n                                 # this value can be safely set to 0.\n\n#db_cache_ttl = 0                # Time-to-live (in seconds) of an entity from\n                                 # the datastore when cached by this node.\n                                 #\n                                 # Database misses (no entity) are also cached\n                                 # according to this setting if you do not\n                                 # configure `db_cache_neg_ttl`.\n                                 #\n                                 # If set to 0 (default), such cached entities\n                                 # or misses never expire.\n\n#db_cache_neg_ttl =              # Time-to-live (in seconds) of a datastore\n                                 # miss (no entity).\n                                 #\n                                 # If not specified (default), `db_cache_ttl`\n                                 # value will be used instead.\n                                 #\n                                 # If set to 0, misses will never expire.\n\n#db_resurrect_ttl = 30           # Time (in seconds) for which stale entities\n                                 # from the datastore should be resurrected for\n                                 # when they cannot be refreshed (e.g., the\n                                 # datastore is unreachable). When this TTL\n                                 # expires, a new attempt to refresh the stale\n                                 # entities will be made.\n\n#db_cache_warmup_entities = services\n                                 # Entities to be pre-loaded from the datastore\n                                 # into the in-memory cache at Kong start-up.\n                                 # This speeds up the first access of endpoints\n                                 # that use the given entities.\n                                 #\n                                 # When the `services` entity is configured\n                                 # for warmup, the DNS entries for values in\n                                 # its `host` attribute are pre-resolved\n                                 # asynchronously as well.\n                                 #\n                                 # Cache size set in `mem_cache_size` should\n                                 # be set to a value large enough to hold all\n                                 # instances of the specified entities.\n                                 # If the size is insufficient, Kong will log\n                                 # a warning.\n\n#------------------------------------------------------------------------------\n# DNS RESOLVER\n#------------------------------------------------------------------------------\n\n# By default, the DNS resolver will use the standard configuration files\n# `/etc/hosts` and `/etc/resolv.conf`. The settings in the latter file will be\n# overridden by the environment variables `LOCALDOMAIN` and `RES_OPTIONS` if\n# they have been set.\n#\n# Kong will resolve hostnames as either `SRV` or `A` records (in that order, and\n# `CNAME` records will be dereferenced in the process).\n# In case a name was resolved as an `SRV` record it will also override any given\n# port number by the `port` field contents received from the DNS server.\n#\n# The DNS options `SEARCH` and `NDOTS` (from the `/etc/resolv.conf` file) will\n# be used to expand short names to fully qualified ones. So it will first try\n# the entire `SEARCH` list for the `SRV` type, if that fails it will try the\n# `SEARCH` list for `A`, etc.\n#\n# For the duration of the `ttl`, the internal DNS resolver will loadbalance each\n# request it gets over the entries in the DNS record. For `SRV` records the\n# `weight` fields will be honored, but it will only use the lowest `priority`\n# field entries in the record.\n\ndns_resolver = 10.4.7.71:8600                 # Comma separated list of nameservers, each\n                                 # entry in `ip[:port]` format to be used by\n                                 # Kong. If not specified the nameservers in\n                                 # the local `resolv.conf` file will be used.\n                                 # Port defaults to 53 if omitted. Accepts\n                                 # both IPv4 and IPv6 addresses.\n\n#dns_hostsfile = /etc/hosts      # The hosts file to use. This file is read\n                                 # once and its content is static in memory.\n                                 # To read the file again after modifying it,\n                                 # Kong must be reloaded.\n\n#dns_order = LAST,SRV,A,CNAME    # The order in which to resolve different\n                                 # record types. The `LAST` type means the\n                                 # type of the last successful lookup (for the\n                                 # specified name). The format is a (case\n                                 # insensitive) comma separated list.\n\n#dns_valid_ttl =                 # By default, DNS records are cached using\n                                 # the TTL value of a response. If this\n                                 # property receives a value (in seconds), it\n                                 # will override the TTL for all records.\n\n#dns_stale_ttl = 4               # Defines, in seconds, how long a record will\n                                 # remain in cache past its TTL. This value\n                                 # will be used while the new DNS record is\n                                 # fetched in the background.\n                                 # Stale data will be used from expiry of a\n                                 # record until either the refresh query\n                                 # completes, or the `dns_stale_ttl` number of\n                                 # seconds have passed.\n\n#dns_not_found_ttl = 30          # TTL in seconds for empty DNS responses and\n                                 # \"(3) name error\" responses.\n\n#dns_error_ttl = 1               # TTL in seconds for error responses.\n\n#dns_no_sync = off               # If enabled, then upon a cache-miss every\n                                 # request will trigger its own dns query.\n                                 # When disabled multiple requests for the\n                                 # same name/type will be synchronised to a\n                                 # single query.\n\n#------------------------------------------------------------------------------\n# TUNING & BEHAVIOR\n#------------------------------------------------------------------------------\n\n#worker_consistency = strict\n                                 # Defines whether this node should rebuild its\n                                 # state synchronously or asynchronously (the\n                                 # balancers and the router are rebuilt on\n                                 # updates that affects them, e.g., updates to\n                                 # Routes, Services or Upstreams, via the Admin\n                                 # API or loading a declarative configuration\n                                 # file).\n                                 #\n                                 # Accepted values are:\n                                 #\n                                 # - `strict`: the router will be rebuilt\n                                 #   synchronously, causing incoming requests to\n                                 #   be delayed until the rebuild is finished.\n                                 # - `eventual`: the router will be rebuilt\n                                 #   asynchronously via a recurring background\n                                 #   job running every second inside of each\n                                 #   worker.\n                                 #\n                                 # Note that `strict` ensures that all workers\n                                 # of a given node will always proxy requests\n                                 # with an identical router, but that increased\n                                 # long tail latency can be observed if\n                                 # frequent Routes and Services updates are\n                                 # expected.\n                                 # Using `eventual` will help preventing long\n                                 # tail latency issues in such cases, but may\n                                 # cause workers to route requests differently\n                                 # for a short period of time after Routes and\n                                 # Services updates.\n\n#worker_state_update_frequency = 5\n                                 # Defines how often the worker state changes are\n                                 # checked with a background job. When a change\n                                 # is detected, a new router or balancer will be\n                                 # built, as needed. Raising this value will\n                                 # decrease the load on database servers and\n                                 # result in less jitter in proxy latency, but\n                                 # it might take more time to propagate changes\n                                 # to each individual worker.\n\n#------------------------------------------------------------------------------\n# MISCELLANEOUS\n#------------------------------------------------------------------------------\n\n# Additional settings inherited from lua-nginx-module allowing for more\n# flexibility and advanced usage.\n#\n# See the lua-nginx-module documentation for more information:\n# https://github.com/openresty/lua-nginx-module\n\n\n#lua_ssl_trusted_certificate =   # Comma-separated list of paths to certificate\n                                 # authority files for Lua cosockets in PEM format.\n                                 #\n                                 # The special value `system` attempts to search for the\n                                 # \"usual default\" provided by each distro, according\n                                 # to an arbitrary heuristic. In the current implementation,\n                                 # The following pathnames will be tested in order,\n                                 # and the first one found will be used:\n                                 #\n                                 # - /etc/ssl/certs/ca-certificates.crt (Debian/Ubuntu/Gentoo)\n                                 # - /etc/pki/tls/certs/ca-bundle.crt (Fedora/RHEL 6)\n                                 # - /etc/ssl/ca-bundle.pem (OpenSUSE)\n                                 # - /etc/pki/tls/cacert.pem (OpenELEC)\n                                 # - /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem (CentOS/RHEL 7)\n                                 # - /etc/ssl/cert.pem (OpenBSD, Alpine)\n                                 #\n                                 # If no file is found on any of these paths, an error will\n                                 # be raised.\n                                 #\n                                 # `system` can be used by itself or in conjunction with other\n                                 # CA filepaths.\n                                 #\n                                 # When `pg_ssl_verify` or `cassandra_ssl_verify`\n                                 # are enabled, these certificate authority files will be\n                                 # used for verifying Kong's database connections.\n                                 #\n                                 # See https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate\n\n#lua_ssl_verify_depth = 1        # Sets the verification depth in the server\n                                 # certificates chain used by Lua cosockets,\n                                 # set by `lua_ssl_trusted_certificate`.\n                                 # This includes the certificates configured\n                                 # for Kong's database connections.\n                                 # If the maximum depth is reached before\n                                 # reaching the end of the chain, verification\n                                 # will fail. This helps mitigate certificate\n                                 # based DoS attacks.\n                                 #\n                                 # See https://github.com/openresty/lua-nginx-module#lua_ssl_verify_depth\n\n#lua_ssl_protocols = TLSv1.1 TLSv1.2 TLSv1.3   # Defines the TLS versions supported\n                                               # when handshaking with OpenResty's\n                                               # TCP cosocket APIs.\n                                               #\n                                               # This affects connections made by Lua\n                                               # code, such as connections to the\n                                               # database Kong uses, or when sending logs\n                                               # using a logging plugin. It does *not*\n                                               # affect connections made to the upstream\n                                               # Service or from downstream clients.\n\n#lua_package_path = ./?.lua;./?/init.lua;  # Sets the Lua module search path\n                                           # (LUA_PATH). Useful when developing\n                                           # or using custom plugins not stored\n                                           # in the default search path.\n                                           #\n                                           # See https://github.com/openresty/lua-nginx-module#lua_package_path\n\n#lua_package_cpath =             # Sets the Lua C module search path\n                                 # (LUA_CPATH).\n                                 #\n                                 # See https://github.com/openresty/lua-nginx-module#lua_package_cpath\n\n#lua_socket_pool_size = 30       # Specifies the size limit for every cosocket\n                                 # connection pool associated with every remote\n                                 # server.\n                                 #\n                                 # See https://github.com/openresty/lua-nginx-module#lua_socket_pool_size\n\n#untrusted_lua = sandbox\n                                 # Controls loading of Lua functions from admin-supplied\n                                 # sources such as the Admin API. LuaJIT bytecode\n                                 # loading is always disabled.\n                                 #\n                                 # **Warning:** LuaJIT is not designed as a secure\n                                 # runtime for running malicious code, therefore\n                                 # you should properly protect your Admin API endpoint\n                                 # even with sandboxing enabled. The sandbox only\n                                 # provides protection against trivial attackers or\n                                 # unintentional modification of the Kong global\n                                 # environment.\n                                 #\n                                 # Accepted values are: `off`, `sandbox`, or\n                                 # `on`:\n                                 #\n                                 # * `off`: Disallow loading of any arbitrary\n                                 #          Lua functions. The `off` option\n                                 #          disables any functionality that runs\n                                 #          arbitrary Lua code, including the\n                                 #          Serverless Functions plugins and any\n                                 #          transformation plugin that allows\n                                 #          custom Lua functions.\n                                 #\n                                 # * `sandbox`: Allow loading of Lua functions,\n                                 #              but use a sandbox when executing\n                                 #              them. The sandboxed function has\n                                 #              restricted access to the global\n                                 #              environment and only has access\n                                 #              to standard Lua functions that\n                                 #              will generally not cause harm to\n                                 #              the Kong Gateway node.\n                                 #\n                                 # * `on`: Functions have unrestricted\n                                 #         access to the global environment and\n                                 #         can load any Lua modules. This is\n                                 #         similar to the behavior in\n                                 #         Kong Gateway prior to 2.3.0.\n                                 #\n                                 # The default `sandbox` environment does not\n                                 # allow importing other modules or libraries,\n                                 # or executing anything at the OS level (for\n                                 # example, file read/write). The global\n                                 # environment is also not accessible.\n                                 #\n                                 # Examples of `untrusted_lua = sandbox`\n                                 # behavior:\n                                 #\n                                 # * You can't access or change global values\n                                 # such as `kong.configuration.pg_password`\n                                 # * You can run harmless lua:\n                                 # `local foo = 1 + 1`. However, OS level\n                                 # functions are not allowed, like:\n                                 # `os.execute('rm -rf /*')`.\n                                 #\n                                 # For a full allowed/disallowed list, see:\n                                 # https://github.com/kikito/sandbox.lua/blob/master/sandbox.lua\n                                 #\n                                 # To customize the sandbox environment, use\n                                 # the `untrusted_lua_sandbox_requires` and\n                                 # `untrusted_lua_sandbox_environment`\n                                 # parameters below.\n\n#untrusted_lua_sandbox_requires = # Comma-separated list of modules allowed to\n                                  # be loaded with `require` inside the\n                                  # sandboxed environment. Ignored\n                                  # if `untrusted_lua` is not `sandbox`.\n                                  #\n                                  # For example, say you have configured the\n                                  # Serverless pre-function plugin and it\n                                  # contains the following `requires`:\n                                  #\n                                  # ```\n                                  # local template = require \"resty.template\"\n                                  # local split = require \"kong.tools.utils\".split\n                                  # ```\n                                  #\n                                  # To run the plugin, add the modules to the\n                                  # allowed list:\n                                  # ```\n                                  # untrusted_lua_sandbox_requires = resty.template, kong.tools.utils\n                                  # ```\n                                  #\n                                  # **Warning:** Allowing certain modules may\n                                  # create opportunities to escape the\n                                  # sandbox. For example, allowing `os` or\n                                  # `luaposix` may be unsafe.\n\n#untrusted_lua_sandbox_environment = # Comma-separated list of global Lua\n                                     # variables that should be made available\n                                     # inside the sandboxed environment. Ignored\n                                     # if `untrusted_lua` is not `sandbox`.\n                                     #\n                                     # **Warning**: Certain variables, when made\n                                     # available, may create opportunities to\n                                     # escape the sandbox.\n"
)
